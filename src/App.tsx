import { useCallback, useEffect, useMemo, useState } from 'react';
import AppLayout from './components/AppLayout';
import ChatPanel from './components/ChatPanel';
import type { ContextCategory } from './components/Sidebar';
import type { ChatMessage } from './types/chat';
import { Aperture, CircuitBoard, Compass, Rocket, Share2 } from 'lucide-react';
import { createChatCompletion, grokIsConfigured } from './lib/grokClient';

const initialContextCategories: ContextCategory[] = [
    {
        id: 'launch-readiness',
        title: 'Launch Readiness',
        icon: Rocket,
        accent: 'from-grokPurple via-grokPink to-grokBlue',
        items: [
            { id: 'lr-1', title: 'Telemetry looks nominal', description: 'Latest staging checks passed with 98.6% health.', emphasis: true, updatedAt: '2m ago' },
            { id: 'lr-2', title: 'Crew comms lag detected', description: 'Latency spike from Sydney relay window.', updatedAt: '4m ago' },
            { id: 'lr-3', title: 'Fuel mix variance 0.7%', description: 'Well within launch corridor tolerance.', updatedAt: '6m ago' }
        ]
    },
    {
        id: 'incident-digest',
        title: 'Incident Digest',
        icon: Aperture,
        accent: 'from-grokBlue via-grokPurple to-grokPink',
        items: [
            { id: 'id-1', title: 'Model drift alert', description: 'Conversational tone shifting in APAC segment.', updatedAt: '10m ago' },
            { id: 'id-2', title: 'Latency degrade risk', description: 'Vector cache eviction rate up 18%.', emphasis: true, updatedAt: '12m ago' },
            { id: 'id-3', title: 'Support backlog', description: 'Flagged threads for escalation review.' }
        ]
    },
    {
        id: 'research-scout',
        title: 'Research Scout',
        icon: CircuitBoard,
        accent: 'from-grokPink via-grokBlue to-grokPurple',
        items: [
            { id: 'rs-1', title: 'Multi-agent planner paper', description: 'Arxiv 2412.101 pending peer review.', updatedAt: '1h ago' },
            { id: 'rs-2', title: 'Competitor launch notes', description: 'Synthesized highlights from Nova One demo.' },
            { id: 'rs-3', title: 'Pricing experimentation log', description: 'Tag with "growth" to pin results.' }
        ]
    },
    {
        id: 'field-intel',
        title: 'Field Intelligence',
        icon: Compass,
        accent: 'from-grokBlue via-grokGreen to-grokPurple',
        items: [
            { id: 'fi-1', title: 'Customer sentiment swing', description: 'Healthcare pilots leaning toward premium tier.', emphasis: true },
            { id: 'fi-2', title: 'Partner beta feedback', description: 'Edge cases from robotics integration stream.' },
            { id: 'fi-3', title: 'Top requested features', description: 'Studio mode, multi-modal logging, agent replay.' }
        ]
    },
    {
        id: 'team-os',
        title: 'Team OS',
        icon: Share2,
        accent: 'from-grokPurple via-grokBlue to-grokGreen',
        items: [
            { id: 'os-1', title: 'Handoff checklist', description: 'Bring ops playbook into next sync.', updatedAt: '30m ago' },
            { id: 'os-2', title: 'Escalation ladder', description: 'Autogenerated from last incident reviews.' },
            { id: 'os-3', title: 'Ops rituals', description: 'Daily review, weekly retro, monthly deep dive.' }
        ]
    }
];

const initialMessages: ChatMessage[] = [
    {
        id: 'sys-1',
        role: 'system',
        content: 'You are Grok, an adaptive operations co-pilot. Maintain a resilient tone and weave in relevant context signals when responding.',
        timestamp: new Date(Date.now() - 1000 * 60 * 25).toISOString()
    },
    {
        id: 'assistant-1',
        role: 'assistant',
        content: 'Morning! I have telemetry, launch readiness, and field intel primed. Want me to draft the 10:00 mission update or scan for new anomalies first?',
        timestamp: new Date(Date.now() - 1000 * 60 * 22).toISOString(),
        tags: ['launch-readiness']
    },
    {
        id: 'user-1',
        role: 'user',
        content: 'Run a quick sweep for emerging risks tied to the Oceania rollout. Anything we should preempt before the all-hands?',
        timestamp: new Date(Date.now() - 1000 * 60 * 21).toISOString()
    },
    {
        id: 'assistant-2',
        role: 'assistant',
        content: 'Two signals surfaced: one around customer onboarding friction in Melbourne pilots, another about latency spike windows when traffic routes through Sydney relay. I can attach mitigation drafts if you want a pre-read.',
        timestamp: new Date(Date.now() - 1000 * 60 * 19).toISOString(),
        tags: ['field-intel', 'launch-readiness']
    }
];

const createId = () =>
    typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
        ? crypto.randomUUID()
        : `id-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`;

function synthesizeAssistantReply(prompt: string, category: ContextCategory): string {
    const anchor = category.items[0]?.title ?? 'selected context';
    const trimmedPrompt = prompt.length > 140 ? `${prompt.slice(0, 140)}…` : prompt;
    return [
        `Pulling from **${anchor}** and adjacent signals.`,
        `Here is the high-signal summary for: "${trimmedPrompt}"`,
        '',
        '• Key risk: latency windows widen during the Sydney relay — reroute through west coast edge for the next six hours.',
        '• Sentiment: onboarding confusion shows up in 14% of Oceania threads, mostly in healthcare pilots; drafting a fixes digest now.',
        '• Next move: spin a sub-thread titled "Oceania preempt" so we can track mitigations and auto-tag any fresh incidents.'
    ].join('\n');
}

export default function App() {
    const [messages, setMessages] = useState<ChatMessage[]>(initialMessages);
    const [categories, setCategories] = useState<ContextCategory[]>(initialContextCategories);
    const [isAssistantTyping, setAssistantTyping] = useState(false);
    const [activeCategoryId, setActiveCategoryId] = useState<string | null>(null);
    const [isSidebarCollapsed, setSidebarCollapsed] = useState(false);
    const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [grokStatusMessage, setGrokStatusMessage] = useState<string | null>(null);
    const [composerTags, setComposerTags] = useState<string[]>(initialContextCategories[0] ? [initialContextCategories[0].id] : []);

    const grokConfigured = useMemo(() => grokIsConfigured(), []);

    const activeCategory = useMemo(
        () => categories.find(category => category.id === activeCategoryId) ?? null,
        [activeCategoryId, categories]
    );

    useEffect(() => {
        if (activeCategoryId) {
            setComposerTags([activeCategoryId]);
        }
    }, [activeCategoryId]);

    const handleSendMessage = useCallback(
        async (content: string, tags: string[]) => {
            const fallbackTag = categories[0]?.id;
            const resolvedTags = tags.length > 0 ? tags : fallbackTag ? [fallbackTag] : [];
            const replyCategory = (categories.find(category => resolvedTags.includes(category.id)) ?? categories[0])!;
            const userMessage: ChatMessage = {
                id: `user-${createId()}`,
                role: 'user',
                content,
                timestamp: new Date().toISOString(),
                tags: resolvedTags
            };
            const nextHistory = [...messages, userMessage];
            setMessages(nextHistory);
            setAssistantTyping(true);

            try {
                const systemPrompt = nextHistory.find(message => message.role === 'system');
                const conversationalMessages = nextHistory.filter(message => message.role !== 'system');
                const trimmedConversation = conversationalMessages.slice(-12);

                const completionMessages = (
                    systemPrompt ? [systemPrompt, ...trimmedConversation] : trimmedConversation
                ).map(message => ({ role: message.role, content: message.content }));

                const assistantText = grokConfigured
                    ? await createChatCompletion(
                        completionMessages,
                        {
                            temperature: 0.6,
                            topP: 0.9,
                            maxTokens: 700
                        }
                    )
                    : synthesizeAssistantReply(content, replyCategory);

                const assistantMessage: ChatMessage = {
                    id: `assistant-${createId()}`,
                    role: 'assistant',
                    content: assistantText,
                    timestamp: new Date().toISOString(),
                    tags: resolvedTags
                };

                setMessages(prev => [...prev, assistantMessage]);
                setGrokStatusMessage(null);
            } catch (error) {
                console.error('Grok completion failed', error);
                const fallback = synthesizeAssistantReply(content, replyCategory);
                const assistantMessage: ChatMessage = {
                    id: `assistant-${createId()}`,
                    role: 'assistant',
                    content: fallback,
                    timestamp: new Date().toISOString(),
                    tags: resolvedTags
                };
                setMessages(prev => [...prev, assistantMessage]);
                const errorMessage =
                    error instanceof Error ? error.message : 'Unexpected error generating Grok response.';
                setGrokStatusMessage(`Grok error: ${errorMessage}`);
            } finally {
                setAssistantTyping(false);
            }
        },
        [categories, grokConfigured, messages]
    );

    const handleToggleComposerTag = useCallback((tagId: string) => {
        setComposerTags(prev => {
            if (prev.includes(tagId)) {
                if (prev.length === 1) {
                    return prev;
                }
                return prev.filter(id => id !== tagId);
            }
            return [...prev, tagId];
        });
    }, []);

    const handleResetComposerTags = useCallback(() => {
        if (activeCategoryId) {
            setComposerTags([activeCategoryId]);
            return;
        }
        if (categories[0]) {
            setComposerTags([categories[0].id]);
            return;
        }
        setComposerTags([]);
    }, [activeCategoryId, categories]);

    const handleUpdateCategoryItems = useCallback(
        (categoryId: string, items: ContextCategory['items']) => {
            setCategories(prev => prev.map(category => (category.id === categoryId ? { ...category, items } : category)));
        },
        []
    );

    const handleRenameCategory = useCallback((categoryId: string, nextTitle: string) => {
        setCategories(prev => prev.map(category => (category.id === categoryId ? { ...category, title: nextTitle } : category)));
    }, []);

    return (
        <AppLayout
            sidebarProps={{
                isCollapsed: isSidebarCollapsed,
                onToggle: () => setSidebarCollapsed(prev => !prev),
                searchQuery,
                onSearchChange: setSearchQuery,
                categories,
                activeCategoryId,
                onSelectCategory: setActiveCategoryId
            }}
            isMobileMenuOpen={mobileMenuOpen}
            onMobileMenuOpen={() => setMobileMenuOpen(true)}
            onMobileMenuClose={() => setMobileMenuOpen(false)}
        >
            <ChatPanel
                title={activeCategory ? activeCategory.title : 'All contexts'}
                subtitle={activeCategory ? 'Editing live context signals and feed.' : 'Synthesizing strategic context, tagging live signals, and queuing next actions for the team.'}
                messages={messages}
                onSendMessage={handleSendMessage}
                isAssistantTyping={isAssistantTyping}
                activeCategory={activeCategory}
                statusMessage={grokStatusMessage}
                isGrokConnected={grokConfigured && !grokStatusMessage}
                contextCategories={categories}
                composerTags={composerTags}
                onToggleComposerTag={handleToggleComposerTag}
                onResetComposerTags={handleResetComposerTags}
                onUpdateCategoryItems={handleUpdateCategoryItems}
                onRenameCategory={handleRenameCategory}
            />
        </AppLayout>
    );
}
