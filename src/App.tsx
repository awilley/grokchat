import { useCallback, useEffect, useMemo, useState } from 'react';
import AppLayout from './components/AppLayout';
import ChatPanel from './components/ChatPanel';
import type { ContextCategory } from './components/Sidebar';
import type { ChatMessage } from './types/chat';
import { Aperture, CircuitBoard, Compass, Rocket, Share2 } from 'lucide-react';
import { createChatCompletion, grokIsConfigured } from './lib/grokClient';

const initialContextCategories: ContextCategory[] = [
    {
        id: 'launch-readiness',
        title: 'Launch Readiness',
        icon: Rocket,
        accent: 'from-grokPurple via-grokPink to-grokBlue',
        items: [
            { id: 'lr-1', title: 'Telemetry looks nominal', description: 'Latest staging checks passed with 98.6% health.', emphasis: true, updatedAt: '2m ago' },
            { id: 'lr-2', title: 'Crew comms lag detected', description: 'Latency spike from Sydney relay window.', updatedAt: '4m ago' },
            { id: 'lr-3', title: 'Fuel mix variance 0.7%', description: 'Well within launch corridor tolerance.', updatedAt: '6m ago' }
        ]
    },
    {
        id: 'incident-digest',
        title: 'Incident Digest',
        icon: Aperture,
        accent: 'from-grokBlue via-grokPurple to-grokPink',
        items: [
            { id: 'id-1', title: 'Model drift alert', description: 'Conversational tone shifting in APAC segment.', updatedAt: '10m ago' },
            { id: 'id-2', title: 'Latency degrade risk', description: 'Vector cache eviction rate up 18%.', emphasis: true, updatedAt: '12m ago' },
            { id: 'id-3', title: 'Support backlog', description: 'Flagged threads for escalation review.' }
        ]
    },
    {
        id: 'research-scout',
        title: 'Research Scout',
        icon: CircuitBoard,
        accent: 'from-grokPink via-grokBlue to-grokPurple',
        items: [
            { id: 'rs-1', title: 'Multi-agent planner paper', description: 'Arxiv 2412.101 pending peer review.', updatedAt: '1h ago' },
            { id: 'rs-2', title: 'Competitor launch notes', description: 'Synthesized highlights from Nova One demo.' },
            { id: 'rs-3', title: 'Pricing experimentation log', description: 'Tag with "growth" to pin results.' }
        ]
    },
    {
        id: 'field-intel',
        title: 'Field Intelligence',
        icon: Compass,
        accent: 'from-grokBlue via-grokGreen to-grokPurple',
        items: [
            { id: 'fi-1', title: 'Customer sentiment swing', description: 'Healthcare pilots leaning toward premium tier.', emphasis: true },
            { id: 'fi-2', title: 'Partner beta feedback', description: 'Edge cases from robotics integration stream.' },
            { id: 'fi-3', title: 'Top requested features', description: 'Studio mode, multi-modal logging, agent replay.' }
        ]
    },
    {
        id: 'team-os',
        title: 'Team OS',
        icon: Share2,
        accent: 'from-grokPurple via-grokBlue to-grokGreen',
        items: [
            { id: 'os-1', title: 'Handoff checklist', description: 'Bring ops playbook into next sync.', updatedAt: '30m ago' },
            { id: 'os-2', title: 'Escalation ladder', description: 'Autogenerated from last incident reviews.' },
            { id: 'os-3', title: 'Ops rituals', description: 'Daily review, weekly retro, monthly deep dive.' }
        ]
    }
];

const initialMessages: ChatMessage[] = [
    {
        id: 'sys-1',
        role: 'system',
        content: 'You are Grok, an adaptive operations co-pilot. Maintain a resilient tone and weave in relevant context signals when responding.',
        timestamp: new Date(Date.now() - 1000 * 60 * 25).toISOString()
    },
    {
        id: 'assistant-1',
        role: 'assistant',
        content: 'Morning! I have telemetry, launch readiness, and field intel primed. Want me to draft the 10:00 mission update or scan for new anomalies first?',
        timestamp: new Date(Date.now() - 1000 * 60 * 22).toISOString(),
        tags: ['launch-readiness']
    },
    {
        id: 'user-1',
        role: 'user',
        content: 'Run a quick sweep for emerging risks tied to the Oceania rollout. Anything we should preempt before the all-hands?',
        timestamp: new Date(Date.now() - 1000 * 60 * 21).toISOString()
    },
    {
        id: 'assistant-2',
        role: 'assistant',
        content: 'Two signals surfaced: one around customer onboarding friction in Melbourne pilots, another about latency spike windows when traffic routes through Sydney relay. I can attach mitigation drafts if you want a pre-read.',
        timestamp: new Date(Date.now() - 1000 * 60 * 19).toISOString(),
        tags: ['field-intel', 'launch-readiness']
    }
];

const createId = () =>
    typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
        ? crypto.randomUUID()
        : `id-${Date.now()}-${Math.random().toString(16).slice(2, 10)}`;

function synthesizeAssistantReply(prompt: string, category: ContextCategory): string {
    const anchor = category.items[0]?.title ?? 'selected context';
    const trimmedPrompt = prompt.length > 140 ? `${prompt.slice(0, 140)}…` : prompt;
    return [
        `Pulling from **${anchor}** and adjacent signals.`,
        `Here is the high-signal summary for: "${trimmedPrompt}"`,
        '',
        '• Key risk: latency windows widen during the Sydney relay — reroute through west coast edge for the next six hours.',
        '• Sentiment: onboarding confusion shows up in 14% of Oceania threads, mostly in healthcare pilots; drafting a fixes digest now.',
        '• Next move: spin a sub-thread titled "Oceania preempt" so we can track mitigations and auto-tag any fresh incidents.'
    ].join('\n');
}

export default function App() {
    const [messages, setMessages] = useState<ChatMessage[]>([]);
    const [categories, setCategories] = useState<ContextCategory[]>(initialContextCategories);
    const [isAssistantTyping, setAssistantTyping] = useState(false);
    const [activeCategoryId, setActiveCategoryId] = useState<string | null>(null);
    const [isSidebarCollapsed, setSidebarCollapsed] = useState(false);
    const [mobileMenuOpen, setMobileMenuOpen] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [grokStatusMessage, setGrokStatusMessage] = useState<string | null>(null);
    const [composerTags, setComposerTags] = useState<string[]>(initialContextCategories[0] ? [initialContextCategories[0].id] : []);
    const [sessionId, setSessionId] = useState<string | null>(null);
    const [historyLoaded, setHistoryLoaded] = useState(false);

    const grokConfigured = useMemo(() => grokIsConfigured(), []);

    // Load categories from DB on mount
    useEffect(() => {
        fetch('/api/categories')
            .then(res => res.ok ? res.json() : Promise.reject('Failed to load categories'))
            .then(data => {
                if (data.categories?.length > 0) {
                    setCategories(data.categories);
                    if (!activeCategoryId && data.categories[0]) {
                        setComposerTags([data.categories[0].id]);
                    }
                }
            })
            .catch(error => {
                console.warn('Could not load categories from DB, using defaults', error);
            });
    }, [activeCategoryId]);

    // Restore chat history from DB if session exists
    useEffect(() => {
        const storedSessionId = localStorage.getItem('grokchat-session-id');
        if (storedSessionId) {
            console.log('[History] Restoring session:', storedSessionId);
            setSessionId(storedSessionId);
            fetch(`/api/messages/${storedSessionId}?limit=100`)
                .then(res => res.ok ? res.json() : Promise.reject('Failed to load messages'))
                .then(data => {
                    console.log('[History] Loaded messages from DB:', data.messages?.length || 0);
                    if (data.messages?.length > 0) {
                        const systemMsg = initialMessages.find(m => m.role === 'system');
                        const restoredMessages = data.messages
                            .reverse() // DB returns DESC, reverse to ASC
                            .filter((msg: any) => msg.role !== 'system') // Filter out system messages from DB
                            .map((msg: any) => ({
                                id: msg.id,
                                role: msg.role,
                                content: msg.content,
                                timestamp: msg.timestamp,
                                tags: msg.tags ? JSON.parse(msg.tags) : undefined
                            }));
                        // Prepend system message if it exists
                        const finalMessages = systemMsg ? [systemMsg, ...restoredMessages] : restoredMessages;
                        console.log('[History] Setting', finalMessages.length, 'messages');
                        setMessages(finalMessages);
                        setHistoryLoaded(true);
                    } else {
                        // No history, use defaults
                        setMessages(initialMessages);
                        setHistoryLoaded(true);
                    }
                })
                .catch(error => {
                    console.warn('Could not restore chat history, using defaults', error);
                    setMessages(initialMessages);
                    setHistoryLoaded(true);
                });
        } else {
            // No session, use defaults
            console.log('[History] No stored session, using defaults');
            setMessages(initialMessages);
            setHistoryLoaded(true);
        }
    }, []);

    // Persist session ID to localStorage
    useEffect(() => {
        if (sessionId) {
            localStorage.setItem('grokchat-session-id', sessionId);
        }
    }, [sessionId]);

    const activeCategory = useMemo(
        () => categories.find(category => category.id === activeCategoryId) ?? null,
        [activeCategoryId, categories]
    );

    useEffect(() => {
        if (activeCategoryId) {
            setComposerTags([activeCategoryId]);
        }
    }, [activeCategoryId]);

    const handleSendMessage = useCallback(
        async (content: string, tags: string[]) => {
            const fallbackTag = categories[0]?.id;
            const resolvedTags = tags.length > 0 ? tags : fallbackTag ? [fallbackTag] : [];
            const replyCategory = (categories.find(category => resolvedTags.includes(category.id)) ?? categories[0])!;
            const userMessage: ChatMessage = {
                id: `user-${createId()}`,
                role: 'user',
                content,
                timestamp: new Date().toISOString(),
                tags: resolvedTags
            };
            const nextHistory = [...messages, userMessage];
            setMessages(nextHistory);
            setAssistantTyping(true);

            try {
                const systemPrompt = nextHistory.find(message => message.role === 'system');
                const conversationalMessages = nextHistory.filter(message => message.role !== 'system');
                const trimmedConversation = conversationalMessages.slice(-12);

                const completionMessages = (
                    systemPrompt ? [systemPrompt, ...trimmedConversation] : trimmedConversation
                ).map(message => ({ role: message.role, content: message.content }));

                let usedMemories: { text: string; type: string; tags: string[] }[] = [];
                let ragDocs: { text: string }[] = [];
                let currentSessionId = sessionId;

                try {
                    const response = await fetch('/api/chat', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            userId: 'demo-user',
                            messages: completionMessages,
                            tags: resolvedTags
                        })
                    });

                    if (response.ok) {
                        const data = await response.json() as { 
                            usedMemories?: { text: string; type: string; tags: string[] }[];
                            ragDocs?: { text: string }[];
                            sessionId?: string;
                        };
                        usedMemories = data.usedMemories ?? [];
                        ragDocs = data.ragDocs ?? [];
                        if (data.sessionId) {
                            currentSessionId = data.sessionId;
                            setSessionId(data.sessionId);
                        }
                    }
                } catch (error) {
                    console.warn('Mem0 /api/chat call failed, continuing without memories', error);
                }

                const memorySection = usedMemories.length
                    ? usedMemories.map(memory => `- (${memory.type}) ${memory.text}`).join('\n')
                    : 'None yet.';

                const knowledgeSection = ragDocs.length
                    ? ragDocs.map(doc => `- ${doc.text}`).join('\n')
                    : 'None available.';

                const grokMessages = [
                    systemPrompt
                        ? {
                            role: systemPrompt.role,
                            content: `${systemPrompt.content}\n\nKnown about this user and context (from memory):\n${memorySection}\n\nRelevant knowledge base:\n${knowledgeSection}`
                        }
                        : {
                            role: 'system' as const,
                            content: `You are Grok, an adaptive operations co-pilot. Maintain a resilient tone and weave in relevant context signals when responding.\n\nKnown about this user and context (from memory):\n${memorySection}\n\nRelevant knowledge base:\n${knowledgeSection}`
                        },
                    ...trimmedConversation.map(message => ({ role: message.role, content: message.content })),
                    { role: 'user' as const, content }
                ];

                const assistantText = grokConfigured
                    ? await createChatCompletion(
                        grokMessages,
                        {
                            temperature: 0.6,
                            topP: 0.9,
                            maxTokens: 700
                        }
                    )
                    : synthesizeAssistantReply(content, replyCategory);

                const assistantMessage: ChatMessage = {
                    id: `assistant-${createId()}`,
                    role: 'assistant',
                    content: assistantText,
                    timestamp: new Date().toISOString(),
                    tags: resolvedTags
                };

                setMessages(prev => [...prev, assistantMessage]);
                setGrokStatusMessage(null);

                // Persist assistant response to DB
                if (currentSessionId) {
                    fetch('/api/chat/response', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId: currentSessionId,
                            content: assistantText,
                            tags: resolvedTags
                        })
                    }).catch(error => console.warn('Failed to persist assistant response', error));
                }
            } catch (error) {
                console.error('Grok completion failed', error);
                const fallback = synthesizeAssistantReply(content, replyCategory);
                const assistantMessage: ChatMessage = {
                    id: `assistant-${createId()}`,
                    role: 'assistant',
                    content: fallback,
                    timestamp: new Date().toISOString(),
                    tags: resolvedTags
                };
                setMessages(prev => [...prev, assistantMessage]);
                const errorMessage =
                    error instanceof Error ? error.message : 'Unexpected error generating Grok response.';
                setGrokStatusMessage(`Grok error: ${errorMessage}`);
            } finally {
                setAssistantTyping(false);
            }
        },
        [categories, grokConfigured, messages]
    );

    const handleToggleComposerTag = useCallback((tagId: string) => {
        setComposerTags(prev => {
            if (prev.includes(tagId)) {
                if (prev.length === 1) {
                    return prev;
                }
                return prev.filter(id => id !== tagId);
            }
            return [...prev, tagId];
        });
    }, []);

    const handleResetComposerTags = useCallback(() => {
        if (activeCategoryId) {
            setComposerTags([activeCategoryId]);
            return;
        }
        if (categories[0]) {
            setComposerTags([categories[0].id]);
            return;
        }
        setComposerTags([]);
    }, [activeCategoryId, categories]);

    const handleUpdateCategoryItems = useCallback(
        (categoryId: string, items: ContextCategory['items']) => {
            setCategories(prev => prev.map(category => (category.id === categoryId ? { ...category, items } : category)));
        },
        []
    );

    const handleRenameCategory = useCallback((categoryId: string, nextTitle: string) => {
        setCategories(prev => prev.map(category => (category.id === categoryId ? { ...category, title: nextTitle } : category)));
    }, []);

    return (
        <AppLayout
            sidebarProps={{
                isCollapsed: isSidebarCollapsed,
                onToggle: () => setSidebarCollapsed(prev => !prev),
                searchQuery,
                onSearchChange: setSearchQuery,
                categories,
                activeCategoryId,
                onSelectCategory: setActiveCategoryId
            }}
            isMobileMenuOpen={mobileMenuOpen}
            onMobileMenuOpen={() => setMobileMenuOpen(true)}
            onMobileMenuClose={() => setMobileMenuOpen(false)}
        >
            <ChatPanel
                title={activeCategory ? activeCategory.title : 'All contexts'}
                subtitle={activeCategory ? 'Editing live context signals and feed.' : 'Synthesizing strategic context, tagging live signals, and queuing next actions for the team.'}
                messages={messages}
                onSendMessage={handleSendMessage}
                isAssistantTyping={isAssistantTyping}
                activeCategory={activeCategory}
                statusMessage={grokStatusMessage}
                isGrokConnected={grokConfigured && !grokStatusMessage}
                contextCategories={categories}
                composerTags={composerTags}
                onToggleComposerTag={handleToggleComposerTag}
                onResetComposerTags={handleResetComposerTags}
                onUpdateCategoryItems={handleUpdateCategoryItems}
                onRenameCategory={handleRenameCategory}
            />
        </AppLayout>
    );
}
